import { ServiceAgent, ServiceAgentType } from "../types.ts";
import { RouteConfig } from "./types.ts";
import { EventEmitter } from "../../../events/emitter.ts";

export class RouterAgent implements ServiceAgent {
  id: string;
  type: ServiceAgentType.ROUTER;
  status: "active" | "inactive" | "error";
  lastHeartbeat: Date;
  metrics: {
    requestsHandled: number;
    successRate: number;
    averageResponseTime: number;
  };

  private routes: Map<string, RouteConfig>;
  private events: EventEmitter;

  constructor() {
    this.id = crypto.randomUUID();
    this.type = ServiceAgentType.ROUTER;
    this.status = "active";
    this.lastHeartbeat = new Date();
    this.metrics = {
      requestsHandled: 0,
      successRate: 100,
      averageResponseTime: 0,
    };
    this.routes = new Map();
    this.events = new EventEmitter();
    this.initializeRouteWatcher();
  }

  async addRoute(config: RouteConfig): Promise<void> {
    this.routes.set(config.path, config);
    await this.generateRouteFile(config);
    this.events.emit("route:added", { config });
  }

  async removeRoute(path: string): Promise<void> {
    this.routes.delete(path);
    await this.cleanupRouteFile(path);
    this.events.emit("route:removed", { path });
  }

  private async generateRouteFile(config: RouteConfig): Promise<void> {
    // Generate route file based on config
    const routeContent = `
      // Generated by RouterAgent
      import { HandlerContext } from "$fresh/server.ts";
      import { AgentRegistry } from "../../core/agents/registry.ts";
      
      export async function handler(req: Request, ctx: HandlerContext) {
        const agent = await AgentRegistry.getInstance().getAgent("${config.agentId}");
        if (!agent) {
          return new Response("Agent not found", { status: 404 });
        }
        
        try {
          const response = await agent.handleRequest(req);
          return new Response(response, { status: 200 });
        } catch (error) {
          console.error("Error handling request:", error);
          return new Response("Internal error", { status: 500 });
        }
      }
    `;

    const routePath = `./routes/${config.path}.ts`;
    await Deno.writeTextFile(routePath, routeContent);
  }

  private async cleanupRouteFile(path: string): Promise<void> {
    const routePath = `./routes/${path}.ts`;
    try {
      await Deno.remove(routePath);
    } catch (error) {
      console.error(`Error removing route file: ${error}`);
    }
  }

  private initializeRouteWatcher(): void {
    // Watch for changes in route configurations
    this.events.on("route:config_changed", async ({ config }) => {
      if (this.routes.has(config.path)) {
        await this.removeRoute(config.path);
      }
      await this.addRoute(config);
    });

    // Monitor route health
    setInterval(() => {
      this.checkRouteHealth();
    }, 60000);
  }

  private async checkRouteHealth(): Promise<void> {
    for (const [path, config] of this.routes.entries()) {
      try {
        const response = await fetch(`http://localhost:8000/${path}`);
        if (!response.ok) {
          this.events.emit("route:health_check_failed", {
            path,
            status: response.status,
          });
        }
      } catch (error) {
        console.error(`Health check failed for route ${path}:`, error);
      }
    }
  }
}
