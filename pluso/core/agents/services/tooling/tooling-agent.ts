import { ServiceAgent, ServiceAgentType } from "../types.ts";
import { ToolConfig } from "./types.ts";
import { EventEmitter } from "../../../events/emitter.ts";

export class ToolingAgent implements ServiceAgent {
  id: string;
  type: ServiceAgentType.TOOLING;
  status: "active" | "inactive" | "error";
  lastHeartbeat: Date;
  metrics: {
    requestsHandled: number;
    successRate: number;
    averageResponseTime: number;
  };

  private tools: Map<string, ToolConfig>;
  private events: EventEmitter;

  constructor() {
    this.id = crypto.randomUUID();
    this.type = ServiceAgentType.TOOLING;
    this.status = "active";
    this.lastHeartbeat = new Date();
    this.metrics = {
      requestsHandled: 0,
      successRate: 100,
      averageResponseTime: 0,
    };
    this.tools = new Map();
    this.events = new EventEmitter();
    this.initializeToolWatcher();
  }

  async configureTool(agentId: string, tool: ToolConfig): Promise<void> {
    this.tools.set(`${agentId}:${tool.name}`, tool);
    await this.generateToolWrapper(agentId, tool);
    this.events.emit("tool:configured", { agentId, tool });
  }

  async removeTool(agentId: string, toolName: string): Promise<void> {
    this.tools.delete(`${agentId}:${toolName}`);
    await this.cleanupToolWrapper(agentId, toolName);
    this.events.emit("tool:removed", { agentId, toolName });
  }

  private async generateToolWrapper(agentId: string, tool: ToolConfig): Promise<void> {
    const wrapperContent = `
      // Generated by ToolingAgent
      import { Tool } from "../../types/tool.ts";
      
      export class ${tool.name}Tool implements Tool {
        name = "${tool.name}";
        description = "${tool.description}";
        
        async execute(params: Record<string, unknown>): Promise<unknown> {
          try {
            // Tool-specific implementation
            ${tool.implementation}
            
            return result;
          } catch (error) {
            console.error(\`Error executing \${this.name}:\`, error);
            throw error;
          }
        }
        
        validate(params: Record<string, unknown>): boolean {
          // Validation logic
          ${tool.validation}
          return true;
        }
      }
    `;

    const wrapperPath = `./tools/${agentId}/${tool.name}.ts`;
    await Deno.writeTextFile(wrapperPath, wrapperContent);
  }

  private async cleanupToolWrapper(agentId: string, toolName: string): Promise<void> {
    const wrapperPath = `./tools/${agentId}/${toolName}.ts`;
    try {
      await Deno.remove(wrapperPath);
    } catch (error) {
      console.error(`Error removing tool wrapper: ${error}`);
    }
  }

  private initializeToolWatcher(): void {
    // Watch for tool configuration changes
    this.events.on("tool:config_changed", async ({ agentId, tool }) => {
      const toolKey = `${agentId}:${tool.name}`;
      if (this.tools.has(toolKey)) {
        await this.removeTool(agentId, tool.name);
      }
      await this.configureTool(agentId, tool);
    });

    // Monitor tool health
    setInterval(() => {
      this.checkToolHealth();
    }, 60000);
  }

  private async checkToolHealth(): Promise<void> {
    for (const [key, tool] of this.tools.entries()) {
      try {
        const [agentId, toolName] = key.split(":");
        const result = await this.testTool(agentId, toolName);
        if (!result.success) {
          this.events.emit("tool:health_check_failed", {
            agentId,
            toolName,
            error: result.error,
          });
        }
      } catch (error) {
        console.error(`Health check failed for tool ${key}:`, error);
      }
    }
  }

  private async testTool(agentId: string, toolName: string): Promise<{ success: boolean; error?: string }> {
    const tool = this.tools.get(`${agentId}:${toolName}`);
    if (!tool) {
      return { success: false, error: "Tool not found" };
    }

    try {
      // Execute tool with test parameters
      const testParams = tool.testParams || {};
      const wrapper = await import(`./tools/${agentId}/${toolName}.ts`);
      const instance = new wrapper[`${toolName}Tool`]();
      await instance.execute(testParams);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}
